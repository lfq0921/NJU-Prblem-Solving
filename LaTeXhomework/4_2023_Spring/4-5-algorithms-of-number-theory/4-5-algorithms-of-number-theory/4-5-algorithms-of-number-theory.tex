% 2-15-rb-tree.tex

%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper, justified]{tufte-handout}
\usepackage{tcolorbox, hyperref, enumerate}
\usepackage{tabu}
\usepackage{xcolor}
\usepackage{listings}
\input{hw-preamble} % feel free to modify this file
%%%%%%%%%%%%%%%%%%%%
\title{第4-5讲: 数论算法}
\me{林凡琪 }{211240042 }{}{}
\date{\zhtoday} % or like 2019年9月13日
%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle
%%%%%%%%%%%%%%%%%%%%
\noplagiarism % always keep this line
%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
	% \begin{center}{\fcolorbox{blue}{yellow!60}{\parbox{0.65\textwidth}{\large 
	%   \begin{itemize}
	%     \item 
	%   \end{itemize}}}}
	% \end{center}
\end{abstract}
%%%%%%%%%%%%%%%%%%%%
\beginrequired

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.1-12]

\end{problem}

\begin{solution}
	基本思想：左移，直到两个数字长度相同，然后使用适当的乘数重复减去并向右移动。

	\begin{algorithm}[H]
		\caption{DIVIDE}
		\begin{algorithmic}[1]
			\Function{Divide}{$n$} \Comment{通常伪代码的函数名是这样特殊的大写}
			\For {$ i = \beta - \alpha, 0 $}
			\While{$a[i,...,i + \alpha -1] -b[0,...,\alpha - 1]\geq 0$}
			\State $a[i,...,i + \alpha -1] -= b[0,...,\alpha - 1]$
			\State $c[i]++$
			\EndWhile
			\EndFor
			\State $d=a$
			\State \Return $c,d$
			\EndFunction
		\end{algorithmic}
	\end{algorithm}

\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.2-5]
\end{problem}

\begin{solution}
	1.当b=0, 不进行递归

	2.当b>1
	根据Lemma 31.10可知：
	$$
		\begin{aligned}
			b \geq F_{k+1} \approx \phi^{k+1} / \sqrt{5} & \Rightarrow \lg _\phi b \geq k+1-\lg _\phi \sqrt{5} \\
			                                             & \Rightarrow k+1 \leq \lg _\phi \sqrt{5}+\lg _\phi b \\
			                                             & \Rightarrow k+1<1.73+\lg _\phi b                    \\
			                                             & \Rightarrow k<1+\lg _\phi b
		\end{aligned}
	$$

	EUCILID(a,b)和EUCLID(a/gcd(a,b),b/gcd(a,b))的递归次数相同。
\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.3-5]
\end{problem}

\begin{solution}
	%To prove it is a permutation, we need to prove that for each element $x \in \mathbb Z_n^*, f_a(x) \in \mathbb Z_n^*$, the numbers generated by $f_a$ are distinct.
	为了证明它是一个置换，我们需要证明对于$\mathbb Z_n^*$中的每个元素$x$，$f_a(x) \in \mathbb Z_n^*$，由$f_a$生成的数字是不同的。

	因为 $a \in \mathbb Z_{n}^*$ 并且 $x \in \mathbb Z_n^*$, 那么 $f_a(x) = ax \mod n \in \mathbb Z_n^*$ （根据closure property）.

	下面利用反证法：
	假设$x,y \in \mathbb{Z}^*_n$，那么，$f_a(x)=f_a(y)$
	$$
		\begin{aligned}
			f_a(x)                       & =f_a(y)                              \\
			a x \quad \bmod n            & =a y \bmod n                         \\
			(a \quad \bmod n)(x \bmod n) & =\left(\begin{array}{ll}
				                                      a & \bmod n
			                                      \end{array}\right)(y \bmod n) \\
			(x \quad \bmod n)            & =y \bmod n                           \\
			x                            & \equiv y \bmod n
		\end{aligned}
	$$
	和假设矛盾。

	得证。
\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.4-2]
\end{problem}

\begin{solution}
	$$d=gcd(ax,n)=gcd(x,n)$$

	因为$ax \cdot x' + n \cdot y' = d$,

	我们有
	$$
		\begin{aligned}
			              & x \cdot\left(a x^{\prime}\right)+n \cdot y^{\prime}=d .    \\
			x_0=          & x^{\prime}(a y / d),                                       \\
			x_0^{\prime}= & \left(a x^{\prime}\right)(y / d)=x^{\prime}(a y / d)=x_0 .
		\end{aligned}
	$$
\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.5-2]
\end{problem}

\begin{solution}
	应用中国剩余定理
	$$
		\begin{gathered}
			n=9 \times 8 \times 7=504 \\
			a_1=1, a_2=2, a_3=3 \\
			m_1=56, m_2=63, m_3=72
		\end{gathered}
	$$
	$m_1^{-1}=5 \bmod 9, m_2^{-1}=7 \bmod 8, m_3^{-1}=4 \bmod 7$
	$$
		\begin{aligned}
			  & c_1=280, c_2=441, c_3=288                               \\
			x & \equiv 280 \times 1+441 \times 2+288 \times 3 \bmod 504 \\
			  & =10 \bmod 504
		\end{aligned}
	$$
\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.6-2]
\end{problem}

\begin{solution}
	\lstdefinestyle{style1}{
		basicstyle=\ttfamily,
		breaklines=true,
		numbers=left,
		keywordstyle=\color{purple}\bfseries,
		identifierstyle=\color{brown!80!black},
		commentstyle=\color{gray},
		showstringspaces=false,
		frame=trBL,
		frameround=fftt,
		backgroundcolor=\color[RGB]{245,245,244},
	}
	\begin{lstlisting}[language=C++,style=style1]
MODULAR-EXPONENTIATION(a, b, n)
i = 0
d = 1
while (1 << i) ≤ b
if (b & (1 << i)) > 0
d = (d * a) % n
a = (a * a) % n
i = i + 1
return d
\end{lstlisting}
\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.1-13(有勘误)]
Give an efficient algorithm to convert a given $\beta$-bit (binary) integer to a decimal representation.
Argue that if multiplication or division of integers whose length is at most $\beta$ takes time \red{ $M(\beta)=\Omega(\beta)$},
then we can convert binary to decimal in time \red{$O(M(\beta)\lg \beta)$}. (Hint: Use a divide-and-conquer approach, obtaining the top and
bottom halves of the result with separate recursions.)

勘误详细参见: \href{https://www.cs.dartmouth.edu/~thc/clrs-bugs/bugs-3e.php}{https://www.cs.dartmouth.edu/~thc/clrs-bugs/bugs-3e.php}
\end{problem}

\begin{solution}
	预处理求出$2^k(0\leq k \leq \beta)$

	分别递归求出左半段L、右半段R

	$$F(X)=F(X.L)*2^{LEN(X.R)}+F(X.R)$$
\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.2-9]
\end{problem}

\begin{solution}
	%Suppose $n_1n_2 x + n_3n_4 y = 1$, then $n_1(n_2 x) + n_3(n_4 y) = 1$, thus $n_1$ and $n_3$ are relatively prime, $n_1$ and $n_4$, $n_2$ and $n_3$, $n_2$ and $n_4$ are the all relatively prime. And since $\gcd(n_1n_3, n_2n_4) = 1$, all the pairs are relatively prime.
	假设 $n_1n_2 x + n_3n_4 y = 1$，则 $n_1(n_2 x) + n_3(n_4 y) = 1$，因此 $n_1$ 和 $n_3$ 互质，$n_1$ 和 $n_4$，$n_2$ 和 $n_3$，$n_2$ 和 $n_4$ 都是互质的。由于 $\gcd(n_1n_3, n_2n_4) = 1$，所有这些数对都是互质的。

	%General: in the first round, divide the elements into two sets with equal number of elements, calculate the products of the two set separately, if the two products are relatively prime, then the element in one set is pairwise relatively prime with the element in the other set. In the next iterations, for each set, we divide the elements into two subsets, suppose we have subsets $\{ (s_1, s_2), (s_3, s_4), \ldots \}$, then we calculate the products of $\{ s_1, s_3, \ldots \}$ and $\{ s_2, s_4, \ldots \}$, if the two products are relatively prime, then all the pairs of subset are pairwise relatively prime similar to the first round. In each iteration, the number of elements in a subset is half of the original set, thus there are $\lceil \lg k \rceil$ pairs of products.
	一般来说，第一轮将元素分成两组，每组元素的数量相等，分别计算两组的乘积，如果两个乘积互质，则一组中的元素与另一组中的元素成对互质。在下一轮迭代中，对于每个组，我们将元素分成两个子集，假设我们有子集 ${ (s_1, s_2), (s_3, s_4), \ldots }$，然后我们计算 ${ s_1, s_3, \ldots }$ 和 ${ s_2, s_4, \ldots }$ 的乘积，如果这两个乘积互质，则所有子集对都成对互质，类似于第一轮。在每次迭代中，子集中的元素数量是原始集合的一半，因此有 $\lceil \lg k \rceil$ 对乘积。

	%To choose the subsets efficiently, in the $k$th iteration, we could divide the numbers based on the value of the index's $k$th bit.
	为了有效地选择子集，在第$k$次迭代中，我们可以根据索引的第$k$位的值将数字分成两部分。
\end{solution}
%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%
\begin{problem}[TC 31.5-3]
\end{problem}

\begin{solution}
	根据TH 31.27

	令 $b=a^{-1}$, 那么
	$$
		b \leftrightarrow\left(b_1, b_2, \cdots, b_k\right), \text { where } b_i=b \bmod n_i
	$$
	只需要证明 $\forall i$ :
	$$
		\begin{aligned}
			 & a_i^{-1}=b_i=(b \bmod n) \bmod n_i                                                                    \\
			 & =\left(a^{-1} \bmod n\right) \bmod n_i                                                                \\
			 & \operatorname{gcd}(a, n)=1 \quad \Rightarrow \operatorname{gcd}\left(a, n_i\right)=1                  \\
			 & \Rightarrow \operatorname{gcd}\left(a \bmod n_i, n_i\right)=\operatorname{gcd}\left(a_i, n_i\right)=1 \\
			 & \Rightarrow a_i \cdot x \equiv 1 \bmod n_i \text { 在模意义下存在唯一解, 记为 } t \text {. }          \\
			 &
		\end{aligned}
	$$
	因为， $t=a_i^{-1} \bmod n_i$. 并且
	$a_i \cdot n_i\left(\left(a^{-1} \bmod n\right) \bmod n_i\right)=\left(a \bmod n_i\right) \cdot n_i\left(a^{-1} \bmod n_i\right)=1$
	所以, $a_i^{-1}=\left(a^{-1} \bmod n\right) \bmod n_i$
\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{problem}[TC 31.6-3]
\end{problem}

\begin{solution}
	$$
		\begin{array}{rlr}
			a^{\phi(n)}           & \equiv 1             & (\bmod n),  \\
			a \cdot a^{\phi(n)-1} & \equiv 1             & (\bmod n),  \\
			a^{-1}                & \equiv a^{\phi(n)-1} & (\bmod n) .
		\end{array}
	$$
\end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%
\beginoptional

%%%%%%%%%%%%%%%
\begin{problem}[同余方程组]
解同余方程组：
$$\begin{array}{ll}
		x & = 3 (\mod 8),   \\
		x & = 11 (\mod 20), \\
		x & =1 (\mod 15).
	\end{array}
$$
\end{problem}

\begin{solution}
\end{solution}
%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%
\beginot
%%%%%%%%%%%%%%%
\begin{ot}[乘法算法]
	请给出n位整数相乘的算法
	\begin{itemize}
		\item $O(n^2)$?
		\item $O(n^{\lg 3})$?
		\item 更快的其他算法？
	\end{itemize}
	(参考资料：\href{https://en.wikipedia.org/wiki/Multiplication_algorithm}{https://en.wikipedia.org/wiki/Multiplication\_algorithm})
\end{ot}

% \begin{solution}
% \end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{ot}[Pollard's rho algorithm]
	Pollard's rho algorithm is an algorithm for integer factorization.

	(参考资料：\href{https://en.wikipedia.org/wiki/Pollard's_rho_algorithm}{https://en.wikipedia.org/wiki/Pollard's\_rho\_algorithm})
\end{ot}


% \begin{solution}
% \end{solution}
%%%%%%%%%%%%%%%


% \vspace{0.50cm}
%%%%%%%%%%%%%%%
% \begin{ot}[]
% 
%   \noindent 参考资料:
%   \begin{itemize}
%     \item 
%   \end{itemize}
% \end{ot}

% \begin{solution}
% \end{solution}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%
% 如果没有需要订正的题目，可以把这部分删掉

% \begincorrection
%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%
% 如果没有反馈，可以把这部分删掉
\beginfb

% 你可以写
% ~\footnote{优先推荐 \href{problemoverflow.top}{ProblemOverflow}}：
% \begin{itemize}
%   \item 对课程及教师的建议与意见
%   \item 教材中不理解的内容
%   \item 希望深入了解的内容
%   \item $\cdots$
% \end{itemize}
%%%%%%%%%%%%%%%%%%%%
% \bibliography{2-5-solving-recurrence}
% \bibliographystyle{plainnat}
%%%%%%%%%%%%%%%%%%%%
\end{document}